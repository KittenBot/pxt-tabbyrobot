<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="y3Ay%4OxeQwjJ_uGKqv/" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="`[dC`OlObUBE}Y0lhd^c" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace tabbyrobot {" line1="    const TABBY_ADDR = 0x16" line2="    const REG_MOTOR = 0x02" line3="    const REG_SERVO1 = 0x03" line4="    const REG_SERVO2 = 0x04" line5="    const REG_HEADLIGHT = 0x05" line6="    const REG_BATTERY = 0x06" line7="" line8="    let neoStrip: neopixel.Strip;" line9="    let distanceBuf = 0;" line10="" line11="" line12="    export enum LeftRight {" line13="        //% block='Left'" line14="        LEFT = 0," line15="        //% block='Right'" line16="        RGIHT = 1," line17="    }" line18="" line19="    export enum Servolist {" line20="        //% block='S1'" line21="        S1 = 0," line22="        //% block='S2'" line23="        S2 = 1," line24="    }" line25="" line26="    /**" line27="     * Init Peripherals on tabby robot" line28="     */" line29="    //% blockId=&quot;tabby_init&quot; block=&quot;Tabby Init&quot;" line30="    //% group=&quot;Tabby&quot;  weight=300" line31="    export function init() {" line32="        pins.i2cWriteNumber(TABBY_ADDR, 0x01, NumberFormat.UInt8BE)" line33="        pins.setPull(DigitalPin.P1, PinPullMode.PullNone)" line34="        pins.setPull(DigitalPin.P2, PinPullMode.PullNone)" line35="    }" line36="" line37="" line38="    /**" line39="     * Init RGB pixels on tabby robot" line40="     */" line41="    //% blockId=&quot;tabby_rgb&quot; block=&quot;Ambient RGB&quot;" line42="    //% group=&quot;Leds&quot;  weight=63" line43="    //% weight=200" line44="    export function rgb(): neopixel.Strip {" line45="        if (!neoStrip) {" line46="            neoStrip = neopixel.create(DigitalPin.P16, 2, NeoPixelMode.RGB)" line47="        }" line48="" line49="        return neoStrip;" line50="    }" line51="" line52="    /**" line53="     * Headlights control" line54="     */" line55="    //% block=&quot;Headlights Left $left Right $right&quot;" line56="    //% group=&quot;Leds&quot;" line57="    //% left.min=0 left.max=100" line58="    //% right.min=0 right.max=100" line59="    //% weight=250" line60="    export function Headlights(left: number, right: number) {" line61="        let buf = pins.createBuffer(3)" line62="        buf[0] = REG_HEADLIGHT" line63="        buf[1] = right" line64="        buf[2] = left" line65="        pins.i2cWriteBuffer(TABBY_ADDR, buf)" line66="" line67="    }" line68="" line69="    /**" line70="     * Motor Speed" line71="     */" line72="    //% block=&quot;Motor $idx Left speed $left Right speed $right&quot;" line73="    //% group=&quot;Motors&quot;" line74="    //% left.shadow=&quot;speedPicker&quot;" line75="    //% right.shadow=&quot;speedPicker&quot;" line76="    //% weight=340" line77="    export function motorRun(left: number, right: number) {" line78="        let buf2 = pins.createBuffer(5)" line79="" line80="" line81="" line82="        // REG, M1A, M1B, M2A, M2B" line83="        buf2[0] = REG_MOTOR" line84="        if (left &gt;= 0) {" line85="            buf2[1] = left" line86="            buf2[2] = 0" line87="" line88="        } else {" line89="            buf2[1] = 0" line90="            buf2[2] = -left" line91="        }" line92="        if (right &gt;= 0) {" line93="            buf2[3] = right" line94="            buf2[4] = 0" line95="        } else {" line96="            buf2[3] = 0" line97="            buf2[4] = -right" line98="        }" line99="" line100="        pins.i2cWriteBuffer(TABBY_ADDR, buf2)" line101="    }" line102="" line103="    /**" line104="     * Motor Stop" line105="     */" line106="    //% block=&quot;Motor Stop All&quot;" line107="    //% group=&quot;Motors&quot;" line108="    //% weight=330" line109="    export function motorStop() {" line110="        let buf3 = pins.createBuffer(5)" line111="        // REG, M1A, M1B, M2A, M2B" line112="        buf3[0] = REG_MOTOR" line113="        buf3[1] = 0" line114="        buf3[2] = 0" line115="        buf3[3] = 0" line116="        buf3[4] = 0" line117="" line118="        pins.i2cWriteBuffer(TABBY_ADDR, buf3)" line119="    }" line120="" line121="    /**" line122="     * Servo Degree" line123="     */" line124="    //% block=&quot;Servo $idx degree $degree&quot;" line125="    //% group=&quot;Motors&quot;" line126="    //% degree.min=0 degree.max=180" line127="    //% weight=300" line128="    export function servoSet(idx: Servolist, degree: number) {" line129="        let buf4 = pins.createBuffer(3)" line130="        buf4[0] = idx == Servolist.S1 ? REG_SERVO1 : REG_SERVO2" line131="        let minPulse = 600" line132="        let maxPulse = 2400" line133="        let v_us = (degree * (maxPulse - minPulse) / 180 + minPulse)" line134="        buf4[1] = v_us &amp; 0xff" line135="        buf4[2] = v_us &gt;&gt; 8" line136="        pins.i2cWriteBuffer(TABBY_ADDR, buf4)" line137="    }" line138="" line139="    /**" line140="     * Line state" line141="     */" line142="    //% block=&quot;Tracking sensor $idx&quot;" line143="    //% group=&quot;Sensor&quot;" line144="    //% weight=300" line145="    export function line(idx: LeftRight): number {" line146="        let value = pins.analogReadPin(idx == LeftRight.LEFT ? AnalogPin.P2 : AnalogPin.P1)" line147="        return value" line148="    }" line149="" line150="    /**" line151="     * Battery voltage" line152="     */" line153="    //% block=&quot;Battery voltage&quot;" line154="    //% group=&quot;Sensor&quot;" line155="    //% weight=200" line156="    export function battery(): number {" line157="        let buf5 = pins.createBuffer(1)" line158="        buf5[0] = REG_BATTERY" line159="        pins.i2cWriteBuffer(TABBY_ADDR, buf5)" line160="        let value2 = pins.i2cReadNumber(TABBY_ADDR, NumberFormat.UInt16BE)" line161="        // VBAT - 27K - ADC - 47K - GND" line162="        // console.log(&quot;adc:&quot;+value)" line163="        value2 = value2 / 65535 * 1.57 * 3.3" line164="        return value2" line165="    }" line166="" line167="    /**" line168="     * signal pin" line169="     * @param pin singal pin; eg: DigitalPin.P1" line170="     * @param unit desired conversion unit" line171="     */" line172="    //% blockId=robotbit_holeultrasonicver block=&quot;Ultrasonic distance&quot;" line173="    //% group=&quot;Sensor&quot;" line174="    //% weight=250" line175="    export function ultrasonic(): number {" line176="        let pin = DigitalPin.P14" line177="        pins.setPull(pin, PinPullMode.PullNone);" line178="        // pins.setPull(pin, PinPullMode.PullDown);" line179="        pins.digitalWritePin(pin, 0);" line180="        control.waitMicros(2);" line181="        pins.digitalWritePin(pin, 1);" line182="        control.waitMicros(10);" line183="        pins.digitalWritePin(pin, 0);" line184="        pins.setPull(pin, PinPullMode.PullUp);" line185="" line186="        // read pulse" line187="        let d = pins.pulseIn(pin, PulseValue.High, 30000);" line188="        let ret = d;" line189="        // filter timeout spikes" line190="        if (ret == 0 &amp;&amp; distanceBuf != 0) {" line191="            ret = distanceBuf;" line192="        }" line193="        distanceBuf = d;" line194="        pins.digitalWritePin(pin, 0);" line195="        basic.pause(15)" line196="        if (parseInt(control.hardwareVersion()) == 2) {" line197="            d = ret * 10 / 58;" line198="        }" line199="        else {" line200="            // return Math.floor(ret / 40 + (ret / 800));" line201="            d = ret * 15 / 58;" line202="        }" line203="        " line204="        return Math.floor(d / 10) " line205="" line206="    }" line207="" line208="" line209="" line210="" line211="" line212="}" numlines="213"></mutation></block></statement></block></xml>